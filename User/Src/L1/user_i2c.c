/**
 * @file user_i2c.c
 *
 * @brief Driver code for interfacing with I2C peripherals.
 */

/* System Headers */
#include "assert.h"
#include "main.h"
#include "cmsis_os2.h"

/* Module Header */
#include "user_i2c.h"

/* Thread flag definitions */
#define I2C_FLAG_DONE (1U << 0)
#define I2C_FLAG_ERROR (1U << 1)

#define I2C_MUX_ADDRESS (0x70 << 1) /* I2C address for the multiplexer */

/* External handles generated by CubeMX */
extern I2C_HandleTypeDef hi2c1;
extern I2C_HandleTypeDef hi2c2;

extern osMessageQueueId_t i2c1_queueHandle;
extern osMessageQueueId_t i2c2_queueHandle;

osThreadId_t i2c1_manager_thread;
osThreadId_t i2c2_manager_thread;

/**
 * @brief Helper function to start an I2C operation and wait for its completion.
 *
 * @param start_status Status returned by the HAL I2C start function
 * @param timeout_ms Timeout duration in milliseconds
 * @return true if the operation completed successfully, false otherwise
 */
static bool I2C_StartAndWait(
    HAL_StatusTypeDef start_status,
    uint32_t timeout_ms)
{
    if (start_status != HAL_OK)
    {
        return false;
    }

    uint32_t flags = osThreadFlagsWait(
        I2C_FLAG_DONE | I2C_FLAG_ERROR,
        osFlagsWaitAny,
        timeout_ms);

    if (flags == osFlagsErrorTimeout)
    {
        return false;
    }

    if ((flags & I2C_FLAG_ERROR) != 0U)
    {
        return false;
    }

    return true;
}

/**
 * @brief Set the I2C multiplexer to the specified channel.
 * @param hi2c Pointer to the I2C handle
 * @param new_channel The new channel to set on the multiplexer
 * @param current_channel Pointer to the current channel variable
 * @param timeout_ms Timeout duration in milliseconds
 * @return true if the channel was set successfully, false otherwise
 */
static bool I2C_SetMuxChannel(
    I2C_HandleTypeDef *hi2c,
    uint8_t new_channel,
    uint8_t *current_channel,
    uint32_t timeout_ms)
{
    if (new_channel == I2C_MUX_NO_CHANNEL ||
        new_channel == *current_channel)
    {
        return true;
    }

    osThreadFlagsClear(I2C_FLAG_DONE | I2C_FLAG_ERROR);

    uint8_t mux_cmd = (1U << new_channel);

    if (!I2C_StartAndWait(
            HAL_I2C_Master_Transmit_IT(
                hi2c,
                I2C_MUX_ADDRESS,
                &mux_cmd,
                1),
            timeout_ms))
    {
        return false;
    }

    *current_channel = new_channel;
    return true;
}

/**
 * @brief Execute an I2C transaction.
 *
 * @param hi2c Pointer to the I2C handle
 * @param transaction Pointer to the I2C transaction structure
 * @param current_mux_channel Pointer to the current multiplexer channel variable
 */
static void I2C_ExecuteTransaction(
    I2C_HandleTypeDef *hi2c,
    I2C_Transaction_t *transaction,
    uint8_t *current_mux_channel)
{
#define I2C_FAIL()                    \
    do                                \
    {                                 \
        transaction->success = false; \
        goto complete;                \
    } while (0)

    transaction->success = false;
    osThreadFlagsClear(I2C_FLAG_DONE | I2C_FLAG_ERROR);

    /* Configure I2C multiplexer if required */
    if (!I2C_SetMuxChannel(
            hi2c,
            transaction->mux_channel,
            current_mux_channel,
            transaction->timeout_ms))
    {
        I2C_FAIL();
    }

    /* First phase */
    switch (transaction->operation)
    {
    case I2C_OP_WRITE:
        if (!I2C_StartAndWait(
                HAL_I2C_Master_Transmit_IT(
                    hi2c,
                    transaction->device_address,
                    transaction->write_buffer,
                    transaction->write_length),
                transaction->timeout_ms))
        {
            I2C_FAIL();
        }
        break;

    case I2C_OP_READ:
        if (!I2C_StartAndWait(
                HAL_I2C_Master_Receive_IT(
                    hi2c,
                    transaction->device_address,
                    transaction->read_buffer,
                    transaction->read_length),
                transaction->timeout_ms))
        {
            I2C_FAIL();
        }
        break;

    case I2C_OP_WRITE_READ:
        if (!I2C_StartAndWait(
                HAL_I2C_Master_Transmit_IT(
                    hi2c,
                    transaction->device_address,
                    transaction->write_buffer,
                    transaction->write_length),
                transaction->timeout_ms))
        {
            I2C_FAIL();
        }

        osThreadFlagsClear(I2C_FLAG_DONE | I2C_FLAG_ERROR);

        if (!I2C_StartAndWait(
                HAL_I2C_Master_Receive_IT(
                    hi2c,
                    transaction->device_address,
                    transaction->read_buffer,
                    transaction->read_length),
                transaction->timeout_ms))
        {
            I2C_FAIL();
        }
        break;

    default:
        I2C_FAIL();
        break;
    }

    transaction->success = true;

complete:
#undef I2C_FAIL
    return;
}

/**
 * @brief I2C Manager Task
 *
 * @param argument Pointer to the I2C bus number (1 or 2)
 */
void I2CManagerTask(void *argument)
{
    I2C_HandleTypeDef *hi2c;
    osMessageQueueId_t queueHandle;
    static uint8_t current_mux_channel = I2C_MUX_NO_CHANNEL;

    switch ((uint8_t)(uintptr_t)argument)
    {
    case 1:
        hi2c = &hi2c1;
        queueHandle = i2c1_queueHandle;
        i2c1_manager_thread = osThreadGetId();
        break;

    case 2:
        hi2c = &hi2c2;
        queueHandle = i2c2_queueHandle;
        i2c2_manager_thread = osThreadGetId();
        break;

    default:
        ASSERT(0 && "Invalid I2C task argument", "I2CManagerTask");
        osThreadTerminate(NULL);
        return;
    }

    while (true)
    {
        I2C_Transaction_t transaction;

        if (osMessageQueueGet(queueHandle, &transaction, NULL, osWaitForever) == osOK)
        {
            I2C_ExecuteTransaction(
                hi2c,
                &transaction,
                &current_mux_channel);

            osSemaphoreRelease(transaction.completion_semaphore);
        }
    }
}